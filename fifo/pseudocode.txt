Подкючаем все нужные библиотеки

int main {
    Проверка на входные значения
    Если больше 2, то вывод ошибки

    Если равно 2, то это отправляющая программа:
        Создаем переменную типа pid_t, инициальзируем ее невалидным значением (-1)
        Открываем fifo с заранее известным именем (Fifo.fifo) с помощью CO-fifo на режим чтения
        Проверяем, открылось ли Fifo.fifo

        (В это время принимающая программа записывает в Fifo.fifo свой pid)

        Считываем при помощи read() pid принимающей программы. Проверяем на корректное считывание.\

        Инициализируем строку с уникальным именем fifo (unique_%d.fifo), где %d это pid принимающей программы (записываем при помощи sprintf).

        Открываем новое fifo (CO-fifo ()) в режиме нонблок и записи. Проверяем на корректное открытие.

        При помощи fcntl выставляем нашему уникальному фифо флаг 0_WRONLY.

        Открываем файл, из которого будет происходить чтение. Проверяем на корректное открытие.

        Используем splice, чтобы перемещать данные напрямую из файла в фифо. Каждый раз проверяем возваращаемое значение, если == 0:
            данные переданы, выход из бесконечного цикла.
        если < 0:
            ошибка


    if equal 1, this is receive programm:
        Открыть фифо с именем Fifo.fifo на режим записи. Проверить на корректное открытие.

        Получаем pid данной программы и записываем его в строку (unique_%d.fifo), где %d это pid данной программы. Записываем данную строку в наш Fifo.fifo.

        Открываем фифо с таким именем на чтение и нонблок. Проверяем на корректное открытие.

        Создаем структуру fd_set unique_Fifo_set {}. Задаем FD_ZERO и FD_SET. Создаем структуру timeval Time {}. Используем select, для того,
        чтобы дождаться изменения статуса фифо. Проверяем на корректное исполнение select.

        Используем fcntl, чтобы убрать nonblock. Проверяем его на корректное исполнение.

        //Изменяем флаги STDOUT_FILENO как flags = flags & ~0_append. Проверяем на корректное выполнение.

        При помощи splice переносим данные из уникального фифо в командную строку (STDOUT_FILENO), пока возвращаемое значение > 0. Если == 0:
            успешное завершение программы.
        Если < 0:
            ошибка.

    return 0;
}

CO-fifo (char* fifo_name, mode_t mode) //create & open fifo
{
    При помощи mkfifo() создаем фифо. Проверяем создано ли оно корректно.

    Возвращаем значение функции open (fifo, mode). mode передается в качестве аргумента.
}